import importlib<br/>import time<br/>import re<br/>from sys import argv<br/>from typing import Optional<br/>import Tianabot.modules.sql.users_sql as sql<div></div>from Tianabot import (<br/>ALLOW_EXCL,<br/>CERT_PATH,<br/>DONATION_LINK,<br/>LOGGER,<br/>OWNER_ID,<br/>PORT,<br/>BOT_TUT,<br/>MUSICBOT_TUT,<br/>UPDATE_CHANNEL,<br/>BOT_USERNAME,<br/>BOT_NAME,<br/>ASS_USERNAME,<br/>START_IMG,<br/>TOKEN,<br/>URL,<br/>OWNER_USERNAME,<br/>WEBHOOK,<br/>SUPPORT_CHAT,<br/>dispatcher,<br/>StartTime,<br/>telethn,<br/>pbot,<br/>updater,<br/>)<div></div># needed to dynamically load modules<br/># NOTE: Module order is not guaranteed, specify that in the config file!<br/>from Tianabot.modules import ALL_MODULES<br/>from Tianabot.modules.helper_funcs.chat_status import is_user_admin<br/>from Tianabot.modules.helper_funcs.misc import paginate_modules<br/>from telegram import InlineKeyboardButton, InlineKeyboardMarkup, ParseMode, Update<br/>from telegram.error import (<br/>BadRequest,<br/>ChatMigrated,<br/>NetworkError,<br/>TelegramError,<br/>TimedOut,<br/>Unauthorized,<br/>)<br/>from telegram.ext import (<br/>CallbackContext,<br/>CallbackQueryHandler,<br/>CommandHandler,<br/>Filters,<br/>MessageHandler,<br/>)<br/>from telegram.ext.dispatcher import DispatcherHandlerStop, run_async<br/>from telegram.utils.helpers import escape_markdown<div></div>def get_readable_time(seconds: int) -> str:<br/>count = 0<br/>ping_time = ""<br/>time_list = []<br/>time_suffix_list = ["s", "m", "h", "days"]<div></div>while count < 4:<br/>count += 1<br/>remainder, result = divmod(seconds, 60) if count < 3 else divmod(seconds, 24)<br/>if seconds == 0 and remainder == 0:<br/>break<br/>time_list.append(int(result))<br/>seconds = int(remainder)<div></div>for x in range(len(time_list)):<br/>time_list[x] = str(time_list[x]) + time_suffix_list[x]<br/>if len(time_list) == 4:<br/>ping_time += time_list.pop() + ", "<div></div>time_list.reverse()<br/>ping_time += ":".join(time_list)<div></div>return ping_time<div></div>PM_START_TEXT = """<br/>*Hᴇʟʟᴏ {} * [!]({})<br/>───────────────────────<br/>× *I'ᴍ Aɴɪᴍᴇ-Tʜᴇᴍᴇ Gʀᴏᴜᴘ Mᴀɴᴀɢᴇᴍᴇɴᴛ Bᴏᴛ*<br/>× *I'ᴍ Vᴇʀʏ Fᴀꜱᴛ Aɴᴅ Mᴏʀᴇ Eꜰꜰɪᴄɪᴇɴᴛ I Pʀᴏᴠɪᴅᴇ Aᴡᴇꜱᴏᴍᴇ Fᴇᴀᴛᴜʀᴇꜱ!*<br/>───────────────────────<br/>× *Uᴘᴛɪᴍᴇ:* `{}`<br/>× `{}` *Uꜱᴇʀ, Aᴄʀᴏꜱꜱ* `{}` *Cʜᴀᴛꜱ.*<br/>───────────────────────"""<div></div>buttons = [<br/>[<br/>InlineKeyboardButton(text="ʜᴇʟᴘ&ᴄᴏᴍᴍᴀɴᴅs", callback_data="tiana_"),<br/>],<br/>[<br/>InlineKeyboardButton(text="ɪɴғᴏ", callback_data="about_"),<br/>InlineKeyboardButton(text="ᴏᴡɴᴇʀ", url=f"https://t.me/{OWNER_USERNAME}"),<br/>],<br/>[<br/>InlineKeyboardButton(text="ᴜᴘᴅᴀᴛᴇs", url=f"http://t.me/{UPDATE_CHANNEL}"),<br/>InlineKeyboardButton(text="sᴜᴘᴘᴏʀᴛ", url=f"https://t.me/{SUPPORT_CHAT}"),<br/>],<br/>[ <br/>InlineKeyboardButton(text="ᴀᴅᴅ ᴛᴇᴄʜɴᴏ ᴛᴏ ʏᴏᴜʀ ɢʀᴏᴜᴘ", url=f"https://t.me/{BOT_USERNAME}?startgroup=true"),<br/>], <div></div>]<div></div>TIANA_IMG = f"{START_IMG}"<br/>TIANA_VIDA = f"{BOT_TUT}"<br/>TIANA_VIDB = f"{MUSICBOT_TUT}"<div></div>HELP_STRINGS = """*Click on the Buttons Bellow to get Documention about Specific Modules*"""<div></div>IMPORTED = {}<br/>MIGRATEABLE = []<br/>HELPABLE = {}<br/>STATS = []<br/>USER_INFO = []<br/>DATA_IMPORT = []<br/>DATA_EXPORT = []<br/>CHAT_SETTINGS = {}<br/>USER_SETTINGS = {}<div></div>for module_name in ALL_MODULES:<br/>imported_module = importlib.import_module("Tianabot.modules." + module_name)<br/>if not hasattr(imported_module, "__mod_name__"):<br/>imported_module.__mod_name__ = imported_module.__name__<div></div>if imported_module.__mod_name__.lower() not in IMPORTED:<br/>IMPORTED[imported_module.__mod_name__.lower()] = imported_module<br/>else:<br/>raise Exception("Can't have two modules with the same name! Please change one")<div></div>if hasattr(imported_module, "__help__") and imported_module.__help__:<br/>HELPABLE[imported_module.__mod_name__.lower()] = imported_module<div></div>if hasattr(imported_module, "__sub_mod__") and imported_module.__sub_mod__:<br/>SUB_MODE[imported_module.__mod_name__.lower()] = imported_module<div></div># Chats to migrate on chat_migrated events<br/>if hasattr(imported_module, "__migrate__"):<br/>MIGRATEABLE.append(imported_module)<div></div>if hasattr(imported_module, "__stats__"):<br/>STATS.append(imported_module)<div></div>if hasattr(imported_module, "__user_info__"):<br/>USER_INFO.append(imported_module)<div></div>if hasattr(imported_module, "__import_data__"):<br/>DATA_IMPORT.append(imported_module)<div></div>if hasattr(imported_module, "__export_data__"):<br/>DATA_EXPORT.append(imported_module)<div></div>if hasattr(imported_module, "__chat_settings__"):<br/>CHAT_SETTINGS[imported_module.__mod_name__.lower()] = imported_module<div></div>if hasattr(imported_module, "__user_settings__"):<br/>USER_SETTINGS[imported_module.__mod_name__.lower()] = imported_module<div></div><br/># do not async<br/>def send_help(chat_id, text, keyboard=None):<br/>if not keyboard:<br/>keyboard = InlineKeyboardMarkup(paginate_modules(0, HELPABLE, "help"))<br/>dispatcher.bot.send_message(<br/>chat_id=chat_id,<br/>text=text,<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=keyboard,<br/>)<div></div><br/>@run_async<br/>def test(update: Update, context: CallbackContext):<br/># pprint(eval(str(update)))<br/># update.effective_message.reply_text("Hola tester! _I_ *have* `markdown`", parse_mode=ParseMode.MARKDOWN)<br/>update.effective_message.reply_text("This person edited a message")<br/>print(update.effective_message)<div></div><br/>@run_async<br/>def start(update: Update, context: CallbackContext):<br/>args = context.args<br/>uptime = get_readable_time((time.time() - StartTime))<br/>if update.effective_chat.type == "private":<br/>if len(args) >= 1:<br/>if args[0].lower() == "help":<br/>send_help(update.effective_chat.id, HELP_STRINGS)<br/>elif args[0].lower().startswith("ghelp_"):<br/>mod = args[0].lower().split("_", 1)[1]<br/>if not HELPABLE.get(mod, False):<br/>return<br/>send_help(<br/>update.effective_chat.id,<br/>HELPABLE[mod].__help__,<br/>InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="⬅️ BACK", callback_data="help_back")]]<br/>),<br/>)<div></div>elif args[0].lower().startswith("stngs_"):<br/>match = re.match("stngs_(.*)", args[0].lower())<br/>chat = dispatcher.bot.getChat(match.group(1))<div></div>if is_user_admin(chat, update.effective_user.id):<br/>send_settings(match.group(1), update.effective_user.id, False)<br/>else:<br/>send_settings(match.group(1), update.effective_user.id, True)<div></div>elif args[0][1:].isdigit() and "rules" in IMPORTED:<br/>IMPORTED["rules"].send_rules(update, args[0], from_pm=True)<div></div>else: <br/>first_name = update.effective_user.first_name<br/>update.effective_message.reply_text(<br/>PM_START_TEXT.format(<br/>escape_markdown(first_name),<br/>START_IMG,<br/>escape_markdown(uptime),<br/>sql.num_users(),<br/>sql.num_chats()),<br/>reply_markup=InlineKeyboardMarkup(buttons),<br/>parse_mode=ParseMode.MARKDOWN,<br/>timeout=60,<br/>)<br/>else:<br/>first_name = update.effective_user.first_name<br/>update.effective_message.reply_photo(<br/>TIANA_IMG, caption="""*Hᴇʟʟᴏ {} !*<br/>───────────────────<br/>× *I'ᴍ Aɴɪᴍᴇ-Tʜᴇᴍᴇ Gʀᴏᴜᴘ Mᴀɴᴀɢᴇᴍᴇɴᴛ Bᴏᴛ*<br/>× *I'ᴍ Vᴇʀʏ Fᴀꜱᴛ Aɴᴅ Mᴏʀᴇ Eꜰꜰɪᴄɪᴇɴᴛ I Pʀᴏᴠɪᴅᴇ Aᴡᴇꜱᴏᴍᴇ Fᴇᴀᴛᴜʀᴇꜱ!*<br/>───────────────────<br/>× *Uᴘᴛɪᴍᴇ:* `{}`<br/>× `{}` *Uꜱᴇʀ, Aᴄʀᴏꜱꜱ* `{}` *Cʜᴀᴛꜱ.*<br/>───────────────────""".format(<br/>escape_markdown(first_name),<br/>escape_markdown(uptime),<br/>sql.num_users(),<br/>sql.num_chats()),<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[InlineKeyboardButton(text="📄 Source", url="https://github.com/prince-botz/tianabot"), <br/>InlineKeyboardButton(text="🫂 Support", url=f"https://t.me/{SUPPORT_CHAT}")]<br/>]<br/>),<br/>parse_mode=ParseMode.MARKDOWN, <br/>)<div></div><br/>def error_handler(update, context):<br/>"""Log the error and send a telegram message to notify the developer."""<br/># Log the error before we do anything else, so we can see it even if something breaks.<br/>LOGGER.error(msg="Exception while handling an update:", exc_info=context.error)<div></div># traceback.format_exception returns the usual python message about an exception, but as a<br/># list of strings rather than a single string, so we have to join them together.<br/>tb_list = traceback.format_exception(<br/>None, context.error, context.error.__traceback__<br/>)<br/>tb = "".join(tb_list)<div></div># Build the message with some markup and additional information about what happened.<br/>message = (<br/>"An exception was raised while handling an update\n"<br/>"update = {}\n\n"<br/>"{}"<br/>).format(<br/>html.escape(json.dumps(update.to_dict(), indent=2, ensure_ascii=False)),<br/>html.escape(tb),<br/>)<div></div>if len(message) >= 4096:<br/>message = message[:4096]<br/># Finally, send the message<br/>context.bot.send_message(chat_id=OWNER_ID, text=message, parse_mode=ParseMode.HTML)<div></div><br/># for test purposes<br/>def error_callback(update: Update, context: CallbackContext):<br/>error = context.error<br/>try:<br/>raise error<br/>except Unauthorized:<br/>print("no nono1")<br/>print(error)<br/># remove update.message.chat_id from conversation list<br/>except BadRequest:<br/>print("no nono2")<br/>print("BadRequest caught")<br/>print(error)<div></div># handle malformed requests - read more below!<br/>except TimedOut:<br/>print("no nono3")<br/># handle slow connection problems<br/>except NetworkError:<br/>print("no nono4")<br/># handle other connection problems<br/>except ChatMigrated as err:<br/>print("no nono5")<br/>print(err)<br/># the chat_id of a group has changed, use e.new_chat_id instead<br/>except TelegramError:<br/>print(error)<br/># handle all other telegram related errors<div></div><br/>@run_async<br/>def help_button(update, context):<br/>query = update.callback_query<br/>mod_match = re.match(r"help_module\((.+?)\)", query.data)<br/>back_match = re.match(r"help_back", query.data)<div></div>print(query.message.chat.id)<div></div>try:<br/>if mod_match:<br/>module = mod_match.group(1)<br/>text = (<br/>"「 Hᴇʟᴘ ᴏғ *{}* 」:\n".format(<br/>HELPABLE[module].__mod_name__<br/>)<br/>+ HELPABLE[module].__help__<br/>)<br/>query.message.edit_text(<br/>text=text,<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="「 Bᴀᴄᴋ 」", callback_data="help_back")]]<br/>),<br/>)<div></div>elif back_match:<br/>query.message.edit_text(<br/>text=HELP_STRINGS,<br/>parse_mode=ParseMode.MARKDOWN,<br/>reply_markup=InlineKeyboardMarkup(<br/>paginate_modules(0, HELPABLE, "help")<br/>),<br/>)<div></div># ensure no spinny white circle<br/>context.bot.answer_callback_query(query.id)<br/># query.message.delete()<div></div>except BadRequest:<br/>pass<div></div><br/>@run_async<br/>def tiana_callback_handler(update, context):<br/>query = update.callback_query<br/>if query.data == "tiana_":<br/>query.message.edit_text(<br/>text="""ᴡᴇʟᴄᴏᴍᴇ ᴛᴏ ʜᴇʟᴘ ᴍᴇɴᴜ. <br/>────────────────────────<br/>*Sᴇʟᴇᴄᴛ Aʟʟ Cᴏᴍᴍᴀɴᴅs Fᴏʀ Fᴜʟʟ Hᴇʟᴘ Oʀ Sᴇʟᴇᴄᴛ Cᴀᴛᴀɢᴏʀʏ Fᴏʀ Mᴏʀᴇ Hᴇʟᴘ Dᴏᴄᴜᴍᴇɴᴛᴀᴛɪᴏɴ Oɴ Sᴇʟᴇᴄᴛᴇᴅ Fɪᴇʟᴅs*""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[<br/>InlineKeyboardButton(text="ᴀʟʟ ᴄᴏᴍᴍᴀɴᴅs", callback_data="help_back"),<br/>], <br/>[InlineKeyboardButton(text="ʜᴏᴡ ᴛᴏ ᴜsᴇ ᴍᴇ", callback_data="tiana_help"),<br/>InlineKeyboardButton(text="ᴍᴜsɪᴄ sʏsᴛᴇᴍ", callback_data="tiana_music")],<br/>[InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="tiana_back"),<br/>InlineKeyboardButton(text="ɪɴʟɪɴᴇ 🔗", switch_inline_query_current_chat="")],<br/>]<br/>),<br/>)<br/>elif query.data == "tiana_back":<br/>first_name = update.effective_user.first_name<br/>uptime = get_readable_time((time.time() - StartTime))<br/>query.message.edit_text(<br/>PM_START_TEXT.format(<br/>escape_markdown(first_name),<br/>START_IMG,<br/>escape_markdown(uptime),<br/>sql.num_users(),<br/>sql.num_chats()),<br/>reply_markup=InlineKeyboardMarkup(buttons),<br/>parse_mode=ParseMode.MARKDOWN,<br/>timeout=60,<br/>disable_web_page_preview=False,<br/>)<br/>elif query.data == "tiana_help":<br/>query.message.edit_text(<br/>text=f"""*Nᴇᴡ Tᴏ {BOT_NAME}! Hᴇʀᴇ Is Tʜᴇ Qᴜɪᴄᴋ Sᴛᴀʀᴛ Gᴜɪᴅᴇ Wʜɪᴄʜ Wɪʟʟ Hᴇʟᴘ Yᴏᴜ Tᴏ Uɴᴅᴇʀsᴛᴀɴᴅ Wʜᴀᴛ Is {BOT_NAME} Aɴᴅ Hᴏᴡ Tᴏ Usᴇ Iᴛ.<div></div>Cʟɪᴄᴋ Bᴇʟᴏᴡ Bᴜᴛᴛᴏɴ Tᴏ Aᴅᴅ Bᴏᴛ Iɴ Yᴏᴜʀ Gʀᴏᴜᴘ. Bᴀsɪᴄ Tᴏᴜʀ Sᴛᴀʀᴛᴇᴅ Tᴏ Kɴᴏᴡ Aʙᴏᴜᴛ Hᴏᴡ Tᴏ Usᴇ Mᴇ*""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="sᴇᴛᴜᴘ ᴛᴜᴛᴏʀɪᴀʟ ", callback_data="tiana_vida")],<br/>[InlineKeyboardButton(text="ᴀᴅᴅ ᴍᴇ ᴛᴏ ʏᴏᴜʀ ɢʀᴏᴜᴘ", url=f"https://t.me/{BOT_USERNAME}?startgroup=true")], <br/>[InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="tiana_"),<br/>InlineKeyboardButton(text="➡️", callback_data="tiana_helpa")]<br/>]<br/>),<br/>)<br/>elif query.data == "tiana_helpa":<br/>query.message.edit_text(<br/>text=f"""<b>Hᴇʏ, Wᴇʟᴄᴏᴍᴇ Tᴏ Cᴏɴғɪɢᴜʀᴀᴛɪᴏɴ Tᴜᴛᴏʀɪᴀʟ</b><div></div><b>Bᴇғᴏʀᴇ Wᴇ Gᴏ, I Nᴇᴇᴅ Aᴅᴍɪɴ Pᴇʀᴍɪssɪᴏɴs Iɴ Tʜɪs Cʜᴀᴛ Tᴏ Wᴏʀᴋ Pʀᴏᴘᴇʀʟʏ.<br/>1). Cʟɪᴄᴋ Mᴀɴᴀɢᴇ Gʀᴏᴜᴘ.<br/>2). Gᴏ Tᴏ Aᴅᴍɪɴɪsᴛʀᴀᴛᴏʀs Aɴᴅ Aᴅᴅ</b> {BOT_USERNAME} <b>As Aᴅᴍɪɴ.<br/>3). Gɪᴠɪɴɢ Fᴜʟʟ Pᴇʀᴍɪssɪᴏɴs Mᴀᴋᴇ Tᴇᴄʜɴᴏ Fᴜʟʟʏ Usᴇғᴜʟ</b>""",<br/>parse_mode=ParseMode.HTML,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="⬅️", callback_data="tiana_help"),<br/>InlineKeyboardButton(text="➡️", callback_data="tiana_helpb")], <br/>]<br/>),<br/>)<br/>elif query.data == "tiana_helpb":<br/>query.message.edit_text(<br/>text="""*Cᴏɴɢʀᴀɢᴜʟᴀᴛɪᴏɴs, Tʜɪꜱ Bᴏᴛ Nᴏᴡ Rᴇᴀᴅʏ Tᴏ Mᴀɴᴀɢᴇ Yᴏᴜʀ Gʀᴏᴜᴘ<div></div>Hᴇʀᴇ Aʀᴇ Sᴏᴍᴇ Essᴇɴᴛɪᴀʟᴛ Tᴏ Tʀʏ Oɴ ᴛᴇᴄʜɴᴏ.<div></div>× Aᴅᴍɪɴ Tᴏᴏʟs<br/>ʙᴀsɪᴄ ᴀᴅᴍɪɴ ᴛᴏᴏʟs ʜᴇʟᴘ ʏᴏᴜ ᴛᴏ ᴘʀᴏᴛᴇᴄᴛ ᴀɴᴅ ᴘᴏᴡᴇʀᴜᴘ ʏᴏᴜʀ ɢʀᴏᴜᴘ<br/>ʏᴏᴜ ᴄᴀɴ ʙᴀɴ ᴍᴇᴍʙᴇʀs, ᴋɪᴄᴋ ᴍᴇᴍʙᴇʀs, ᴘʀᴏᴍᴏᴛᴇ sᴏᴍᴇᴏɴᴇ ᴀs ᴀᴅᴍɪɴ ᴛʜʀᴏᴜɢʜ ᴄᴏᴍᴍᴀɴᴅs ᴏғ ʙᴏᴛ<div></div>× Wᴇʟᴄᴏᴍᴇs<br/>ʟᴇᴛs sᴇᴛ ᴀ ᴡᴇʟᴄᴏᴍᴇ ᴍᴇssᴀɢᴇ ᴛᴏ ᴡᴇʟᴄᴏᴍᴇ ɴᴇᴡ ᴜsᴇʀs ᴄᴏᴍɪɴɢ ᴛᴏ ʏᴏᴜʀ ɢʀᴏᴜᴘ<br/>sᴇɴᴅ /setwelcome [ᴍᴇssᴀɢᴇ] ᴛᴏ sᴇᴛ ᴀ ᴡᴇʟᴄᴏᴍᴇ ᴍᴇssᴀɢᴇ<br/>ᴀʟsᴏ ʏᴏᴜ ᴄᴀɴ sᴛᴏᴘ ᴇɴᴛᴇʀɪɴɢ ʀᴏʙᴏᴛs ᴏʀ sᴘᴀᴍᴍᴇʀs ᴛᴏ ʏᴏᴜʀ ᴄʜᴀᴛ ʙʏ sᴇᴛᴛɪɴɢ ᴡᴇʟᴄᴏᴍᴇ ᴄᴀᴘᴛᴄʜᴀ <div></div>Rᴇғᴇʀ Hᴇʟᴘ Mᴇɴᴜ Tᴏ Sᴇᴇ Eᴠᴇʀʏᴛʜɪɴɢ Iɴ Dᴇᴛᴀɪʟ*""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[InlineKeyboardButton(text="⬅️", callback_data="tiana_helpa"),<br/>InlineKeyboardButton(text="➡️", callback_data="tiana_helpc")]<br/>]<br/>),<br/>)<br/>elif query.data == "tiana_helpc":<br/>query.message.edit_text(<br/>text="""*× Fɪʟᴛᴇʀs<br/>ғɪʟᴛᴇʀs ᴄᴀɴ ʙᴇ ᴜsᴇᴅ ᴀs ᴀᴜᴛᴏᴍᴀᴛᴇᴅ ʀᴇᴘʟɪᴇs/ʙᴀɴ/ᴅᴇʟᴇᴛᴇ ᴡʜᴇɴ sᴏᴍᴇᴏɴᴇ ᴜsᴇ ᴀ ᴡᴏʀᴅ ᴏʀ sᴇɴᴛᴇɴᴄᴇ<br/>ғᴏʀ ᴇxᴀᴍᴘʟᴇ ɪғ ɪ ғɪʟᴛᴇʀ ᴡᴏʀᴅ 'ʜᴇʟʟᴏ' ᴀɴᴅ sᴇᴛ ʀᴇᴘʟʏ ᴀs 'ʜɪ'<br/>ʙᴏᴛ ᴡɪʟʟ ʀᴇᴘʟʏ ᴀs 'ʜɪ' ᴡʜᴇɴ sᴏᴍᴇᴏɴᴇ sᴀʏ 'ʜᴇʟʟᴏ'<br/>ʏᴏᴜ ᴄᴀɴ ᴀᴅᴅ ғɪʟᴛᴇʀs ʙʏ sᴇɴᴅɪɴɢ /filter ғɪʟᴛᴇʀ ɴᴀᴍᴇ<div></div>× Aɪ CʜᴀᴛBᴏᴛ<br/>ᴡᴀɴᴛ sᴏᴍᴇᴏɴᴇ ᴛᴏ ᴄʜᴀᴛ ɪɴ ɢʀᴏᴜᴘ?<br/>Tᴇᴄʜɴᴏ ʜᴀs ᴀɴ ɪɴᴛᴇʟʟɪɢᴇɴᴛ ᴄʜᴀᴛʙᴏᴛ ᴡɪᴛʜ ᴍᴜʟᴛɪʟᴀɴɢ sᴜᴘᴘᴏʀᴛ<br/>ʟᴇᴛ's ᴛʀʏ ɪᴛ,<br/>Sᴇɴᴅ /chatbot Oɴ Aɴᴅ Rᴇᴘʟʏ Tᴏ Aɴʏ Oғ Mʏ Mᴇssᴀɢᴇs Tᴏ Sᴇᴇ Tʜᴇ Mᴀɢɪᴄ*""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[InlineKeyboardButton(text="⬅️", callback_data="tiana_helpb"),<br/>InlineKeyboardButton(text="➡️", callback_data="tiana_helpd")]<br/>]<br/>),<br/>)<br/>elif query.data == "tiana_helpd":<br/>query.message.edit_text(<br/>text="""*× Sᴇᴛᴛɪɴɢ Uᴘ Nᴏᴛᴇs<br/>ʏᴏᴜ ᴄᴀɴ sᴀᴠᴇ ᴍᴇssᴀɢᴇ/ᴍᴇᴅɪᴀ/ᴀᴜᴅɪᴏ ᴏʀ ᴀɴʏᴛʜɪɴɢ ᴀs ɴᴏᴛᴇs ᴜsɪɴɢ /notes<br/>ᴛᴏ ɢᴇᴛ ᴀ ɴᴏᴛᴇ sɪᴍᴘʟʏ ᴜsᴇ # ᴀᴛ ᴛʜᴇ ʙᴇɢɪɴɴɪɴɢ ᴏғ ᴀ ᴡᴏʀᴅ<br/>sᴇᴇ ᴛʜᴇ ɪᴍᴀɢᴇ..<div></div>× Sᴇᴛᴛɪɴɢ Uᴘ Nɪɢʜᴛᴍᴏᴅᴇ<br/>ʏᴏᴜ ᴄᴀɴ sᴇᴛ ᴜᴘ ɴɪɢʜᴛᴍᴏᴅᴇ ᴜsɪɴɢ /nightmode ᴏɴ/ᴏғғ ᴄᴏᴍᴍᴀɴᴅ.<div></div>Nᴏᴛᴇ- ɴɪɢʜᴛ ᴍᴏᴅᴇ ᴄʜᴀᴛs ɢᴇᴛ ᴀᴜᴛᴏᴍᴀᴛɪᴄᴀʟʟʏ ᴄʟᴏsᴇᴅ ᴀᴛ 12ᴘᴍ(ɪsᴛ)<br/>ᴀɴᴅ ᴀᴜᴛᴏᴍᴀᴛɪᴄᴀʟʟʏ ᴏᴘᴇɴɴᴇᴅ ᴀᴛ 6ᴀᴍ(ɪsᴛ) ᴛᴏ ᴘʀᴇᴠᴇɴᴛ ɴɪɢʜᴛ sᴘᴀᴍs.*""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[InlineKeyboardButton(text="⬅️", callback_data="tiana_helpc"),<br/>InlineKeyboardButton(text="➡️", callback_data="tiana_helpe")]<br/>]<br/>),<br/>)<br/>elif query.data == "tiana_term":<br/>query.message.edit_text(<br/>text=f"""✗ *Terms and Conditions:*<div></div>- Only your first name, last name (if any) and username (if any) is stored for a convenient communication!<br/>- No group ID or it's messages are stored, we respect everyone's privacy.<br/>- Messages between Bot and you is only infront of your eyes and there is no backuse of it.<br/>- Watch your group, if someone is spamming your group, you can use the report feature of your Telegram Client.<br/>- Do not spam commands, buttons, or anything in bot PM.<div></div>*NOTE:* Terms and Conditions might change anytime""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[InlineKeyboardButton(text="ᴜᴘᴅᴀᴛᴇs", url=f"https://t.me/{UPDATE_CHANNEL}"), <br/>InlineKeyboardButton(text="sᴜᴘᴘᴏʀᴛ", url=f"https://t.me/{SUPPORT_CHAT}")], <br/>[InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="about_")]]<br/>),<br/>)<br/>elif query.data == "tiana_helpe":<br/>query.message.edit_text(<br/>text="""*× Sᴏ Nᴏᴡ Yᴏᴜ Aʀᴇ Aᴛ Tʜᴇ Eɴᴅ Oғ Bᴀsɪᴄ Tᴏᴜʀ. Bᴜᴛ Tʜɪs Is Nᴏᴛ Aʟʟ I Cᴀɴ Dᴏ.<div></div>Sᴇɴᴅ /help Iɴ Bᴏᴛ Pᴍ Tᴏ Aᴄᴄᴇss Hᴇʟᴘ Mᴇɴᴜ<div></div>Tʜᴇʀᴇ Aʀᴇ Mᴀɴʏ Hᴀɴᴅʏ Tᴏᴏʟs Tᴏ Tʀʏ Oᴜᴛ. <br/>Aɴᴅ Aʟsᴏ Iғ Yᴏᴜ Hᴀᴠᴇ Aɴʏ Sᴜɢɢᴇssɪᴏɴs Aʙᴏᴜᴛ Mᴇ, Dᴏɴ'ᴛ Fᴏʀɢᴇᴛ Tᴏ tᴇʟʟ Tʜᴇᴍ Tᴏ Dᴇᴠs<div></div>Aɢᴀɪɴ Tʜᴀɴᴋs Fᴏʀ Usɪɴɢ Mᴇ<div></div>× Bʏ Usɪɴɢ Tʜɪꜱ Bᴏᴛ Yᴏᴜ Aʀᴇ Aɢʀᴇᴇᴅ Tᴏ Oᴜʀ Tᴇʀᴍs & Cᴏɴᴅɪᴛɪᴏɴs*""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="ᴀʟʟ ᴄᴏᴍᴍᴀɴᴅs", callback_data="help_back")],<br/>[InlineKeyboardButton(text="⬅️", callback_data="tiana_helpd"),<br/>InlineKeyboardButton(text="ᴍᴀɪɴ ᴍᴇɴᴜ", callback_data="tiana_")]]<br/>),<br/>)<br/>elif query.data == "tiana_music":<br/>query.message.edit_text(<br/>text=f"""*Hᴇʀᴇ Iꜱ Tʜᴇ Hᴇʟᴘ 「Aꜱꜱɪꜱᴛᴀɴᴛ」 Mᴏᴅᴜʟᴇ:*<div></div>1.) first, add me to your group.<div></div>2.) then promote me as admin and give all permissions except anonymous admin.<div></div>3.) add Assistant to your group using /userbotjoin.<div></div>4.) turn on the video chat first before start to play music.<div></div>*Lets Enjoy Music Bot And Join Support Group*""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="sᴇᴛᴜᴘ ᴛᴜᴛᴏʀɪᴀʟ", callback_data="tiana_vidb")],<br/>[InlineKeyboardButton(text="ᴘʟᴀʏ ᴄᴏᴍᴍᴀɴᴅs", callback_data="tiana_musica"),<br/>InlineKeyboardButton(text="ʙᴏᴛ ᴄᴍᴍᴀɴᴅs", callback_data="tiana_musicc")],<br/>[InlineKeyboardButton(text="ᴀᴅᴍɪɴs ᴄᴏᴍᴍᴀɴᴅ", callback_data="tiana_musicb"),<br/>InlineKeyboardButton(text="ᴇxᴛʀᴀ ᴄᴏᴍᴍᴀɴᴅs", callback_data="tiana_musicd")],<br/>[InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="tiana_")]<br/>]<br/>),<br/>)<br/>elif query.data == "tiana_musica":<br/>query.message.edit_text(<br/>text="""✗*Here is the help for Play Commands*:<div></div>*Note*: Techno Music Bot works on a single merged commands for Music and Video<div></div>✗ *Youtube and Telegram Files*:<div></div>/play [Reply to any Video or Audio] or [YT Link] or [Music Name] <br/>- Stream Video or Music on Voice Chat by selecting inline Buttons you get<div></div><br/>✗ *Techno Database Saved Playlists*:<div></div>/createplaylist<br/>- Create Your Playlist on Tiana's Server with Custom Name<div></div>/playlist <br/>- Check Your Saved Playlist On Servers.<div></div>/deleteplaylist<br/>- Delete any saved music in your playlist<div></div>/playplaylist <br/>- Start playing Your Saved Playlist on Tiana Servers.""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="tiana_music")]]<br/>),<br/>)<br/>elif query.data == "tiana_musicb":<br/>query.message.edit_text(<br/>text="""✗ *Here is the help for Admin Commands*:<div></div><br/>✗ *Admin Commands*:<div></div>/pause <br/>- Pause the playing music on voice chat.<div></div>/resume<br/>- Resume the paused music on voice chat.<div></div>/skip<br/>- Skip the current playing music on voice chat<div></div>/end or /stop<br/>- Stop the playout.<div></div><br/>✗ *Authorised Users List*:<div></div>Tᴇᴄʜɴᴏ has a additional feature for non-admin users who want to use admin commands<br/>-Auth users can skip, pause, stop, resume Voice Chats even without Admin Rights.<div></div><br/>/auth [Username or Reply to a Message] <br/>- Add a user to AUTH LIST of the group.<div></div>/unauth [Username or Reply to a Message] <br/>- Remove a user from AUTH LIST of the group.<div></div>/authusers <br/>- Check AUTH LIST of the group.""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="tiana_music")]]<br/>),<br/>)<br/>elif query.data == "tiana_musicc":<br/>query.message.edit_text(<br/>text="""✗ *Here is the help for Bot Commands*:<div></div><br/>/start <br/>- Start the ᴛᴇᴄʜɴᴏ Music Bot.<div></div>/help <br/>- Get Commands Helper Menu with detailed explanations of commands.<div></div>/settings <br/>- Get Settings dashboard of a group. You can manage Auth Users Mode. Commands Mode from here.<div></div>/ping<br/>- Ping the Bot and check Ram, Cpu etc stats of Tiana.""",<br/>parse_mode=ParseMode.HTML,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="tiana_music")]]<br/>),<br/>)<br/>elif query.data == "tiana_musicd":<br/>query.message.edit_text(<br/>text=""" *Here is the help for Extra Commands*:<div></div>/lyrics [Music Name]<br/>- Searches Lyrics for the particular Music on web.<div></div>/sudolist <br/>- Check Sudo Users of Tiana Music Bot<div></div>/song [Track Name] or [YT Link]<br/>- Download any track from youtube in mp3 or mp4 formats via Tiana.<div></div>/queue<br/>- Check Queue List of Music.<div></div>/cleanmode [Enable|Disable]<br/>- When enabled, Tiana will be deleting her 3rd last message to keep your chat clean.""",<br/>parse_mode=ParseMode.HTML,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="tiana_music")]]<br/>),<br/>)<br/>elif query.data == "tiana_about":<br/>query.message.edit_text(<br/>text=f"""{BOT_NAME} it's online since January 2022 and it's constantly updated!<div></div>Bot Admins<div></div>• @{OWNER_USERNAME}, bot creator and main developer.<div></div>• The Doctor, server manager and developer.<div></div>• Manuel 5, developer.<div></div>Support<div></div>• [Click here](https://t.me/{SUPPORT_CHAT}) to consult the updated list of Official Supporters of the bot.<div></div>• Thanks to all our donors for supporting server and development expenses and all those who have reported bugs or suggested new features.<div></div>• We also thank all the groups who rely on our Bot for this service, we hope you will always like it: we are constantly working to improve it!""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="about_")]]<br/>),<br/>)<br/>elif query.data == "tiana_support":<br/>query.message.edit_text(<br/>text=f"*{BOT_NAME} Support Chats*",<br/>parse_mode=ParseMode.MARKDOWN,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[<br/>InlineKeyboardButton(text="Nᴇᴡꜱ", url=f"t.me/{UPDATE_CHANNEL}"),<br/>InlineKeyboardButton(text="Dᴏɴᴀᴛᴇ Mᴇ", url=f"{DONATION_LINK}"),<br/>],<br/>[<br/>InlineKeyboardButton(text="Sᴜᴘᴘᴏʀᴛ", url=f"t.me/{SUPPORT_CHAT}"),<br/>InlineKeyboardButton(text="Uᴘᴅᴀᴛᴇꜱ", url=f"https://t.me/{UPDATE_CHANNEL}"),<br/>],<br/>[<br/>InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="about_"),<div></div>]<br/>]<br/>),<br/>)<br/>elif query.data == "tiana_source":<br/>query.message.edit_text(<br/>text="""*ᴛᴇᴄʜɴᴏ ʙᴏᴛ is Now Open Source Bot Project.*<div></div>*Click below Button to Get Source Code.*""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[<br/>InlineKeyboardButton(text="📄 sᴏᴜʀᴄᴇ", url="github.com/Prince-Botz/Tianabot"), <br/>InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="about_"),<br/>] <br/>]<br/>),<br/>)<br/>elif query.data == "tiana_vida":<br/>query.message.reply_video(<br/>TIANA_VIDA,<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True, <br/>)<br/>elif query.data == "tiana_vidb":<br/>query.message.reply_video(<br/>TIANA_VIDB,<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True, <br/>)<div></div>@run_async<br/>def tiana_about_callback(update: Update, context: CallbackContext):<br/>query = update.callback_query<br/>if query.data == "about_":<br/>query.message.edit_text(<br/>text="""ᴄʟɪᴄᴋ ʙᴇʟᴏᴡ ʙᴜᴛᴛᴏɴ ғᴏʀ ᴋɴᴏᴡ ᴍᴏʀᴇ ᴀʙᴏᴜᴛ ᴍᴇ""",<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[<br/>InlineKeyboardButton(text="ᴀʙᴏᴜᴛ", callback_data="tiana_about"),<br/>InlineKeyboardButton(text="sᴏᴜʀᴄᴇ", callback_data="tiana_source"),<br/>],<br/>[ <br/>InlineKeyboardButton(text="sᴜᴘᴘᴏʀᴛ", callback_data="tiana_support"),<br/>InlineKeyboardButton(text="ᴏᴡɴᴇʀ", url=f"t.me/{OWNER_USERNAME}"),<br/>],<br/>[<br/>InlineKeyboardButton(text="ᴛᴇᴀʀᴍs ᴀɴᴅ ᴄᴏɴᴅɪᴛɪᴏɴ", callback_data="tiana_term"),<br/>],<br/>[<br/>InlineKeyboardButton(text="🔙 ʙᴀᴄᴋ", callback_data="about_back"),<br/>] <br/>]<br/>),<br/>)<br/>elif query.data == "about_back":<br/>first_name = update.effective_user.first_name<br/>uptime = get_readable_time((time.time() - StartTime))<br/>query.message.edit_text(<br/>PM_START_TEXT.format(<br/>escape_markdown(first_name),<br/>START_IMG,<br/>escape_markdown(uptime),<br/>sql.num_users(),<br/>sql.num_chats()),<br/>reply_markup=InlineKeyboardMarkup(buttons),<br/>parse_mode=ParseMode.MARKDOWN,<br/>timeout=60,<br/>disable_web_page_preview=False,<br/>)<div></div>@run_async<br/>def get_help(update: Update, context: CallbackContext):<br/>chat = update.effective_chat # type: Optional[Chat]<br/>args = update.effective_message.text.split(None, 1)<div></div># ONLY send help in PM<br/>if chat.type != chat.PRIVATE:<br/>if len(args) >= 2 and any(args[1].lower() == x for x in HELPABLE):<br/>module = args[1].lower()<br/>update.effective_message.reply_text(<br/>f"Contact me in PM to get help of {module.capitalize()}",<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[<br/>InlineKeyboardButton(<br/>text="Help",<br/>url="t.me/{}?start=ghelp_{}".format(<br/>context.bot.username, module<br/>),<br/>)<br/>]<br/>]<br/>),<br/>)<br/>return<br/>update.effective_message.reply_text(<br/>"Contact me in PM to get the list of possible commands.",<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[<br/>InlineKeyboardButton(<br/>text="Help",<br/>url="t.me/{}?start=help".format(context.bot.username),<br/>)<br/>]<br/>]<br/>),<br/>)<br/>return<div></div>elif len(args) >= 2 and any(args[1].lower() == x for x in HELPABLE):<br/>module = args[1].lower()<br/>text = (<br/>"Here is the available help for the *{}* module:\n".format(<br/>HELPABLE[module].__mod_name__<br/>)<br/>+ HELPABLE[module].__help__<br/>)<br/>send_help(<br/>chat.id,<br/>text,<br/>InlineKeyboardMarkup(<br/>[[InlineKeyboardButton(text="Back", callback_data="tiana_")]]<br/>),<br/>)<div></div>else:<br/>send_help(chat.id, HELP_STRINGS)<div></div><br/>def send_settings(chat_id, user_id, user=False):<br/>if user:<br/>if USER_SETTINGS:<br/>settings = "\n\n".join(<br/>"*{}*:\n{}".format(mod.__mod_name__, mod.__user_settings__(user_id))<br/>for mod in USER_SETTINGS.values()<br/>)<br/>dispatcher.bot.send_message(<br/>user_id,<br/>"These are your current settings:" + "\n\n" + settings,<br/>parse_mode=ParseMode.MARKDOWN,<br/>)<div></div>else:<br/>dispatcher.bot.send_message(<br/>user_id,<br/>"Seems like there aren't any user specific settings available :'(",<br/>parse_mode=ParseMode.MARKDOWN,<br/>)<div></div>else:<br/>if CHAT_SETTINGS:<br/>chat_name = dispatcher.bot.getChat(chat_id).title<br/>dispatcher.bot.send_message(<br/>user_id,<br/>text="Which module would you like to check {}'s settings for?".format(<br/>chat_name<br/>),<br/>reply_markup=InlineKeyboardMarkup(<br/>paginate_modules(0, CHAT_SETTINGS, "stngs", chat=chat_id)<br/>),<br/>)<br/>else:<br/>dispatcher.bot.send_message(<br/>user_id,<br/>"Seems like there aren't any chat settings available :'(\nSend this "<br/>"in a group chat you're admin in to find its current settings!",<br/>parse_mode=ParseMode.MARKDOWN,<br/>)<div></div><br/>@run_async<br/>def settings_button(update: Update, context: CallbackContext):<br/>query = update.callback_query<br/>user = update.effective_user<br/>bot = context.bot<br/>mod_match = re.match(r"stngs_module\((.+?),(.+?)\)", query.data)<br/>prev_match = re.match(r"stngs_prev\((.+?),(.+?)\)", query.data)<br/>next_match = re.match(r"stngs_next\((.+?),(.+?)\)", query.data)<br/>back_match = re.match(r"stngs_back\((.+?)\)", query.data)<br/>try:<br/>if mod_match:<br/>chat_id = mod_match.group(1)<br/>module = mod_match.group(2)<br/>chat = bot.get_chat(chat_id)<br/>text = "*{}* has the following settings for the *{}* module:\n\n".format(<br/>escape_markdown(chat.title), CHAT_SETTINGS[module].__mod_name__<br/>) + CHAT_SETTINGS[module].__chat_settings__(chat_id, user.id)<br/>query.message.reply_text(<br/>text=text,<br/>parse_mode=ParseMode.MARKDOWN,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[<br/>InlineKeyboardButton(<br/>text="Back",<br/>callback_data="stngs_back({})".format(chat_id),<br/>)<br/>]<br/>]<br/>),<br/>)<div></div>elif prev_match:<br/>chat_id = prev_match.group(1)<br/>curr_page = int(prev_match.group(2))<br/>chat = bot.get_chat(chat_id)<br/>query.message.reply_text(<br/>"Hi there! There are quite a few settings for {} - go ahead and pick what "<br/>"you're interested in.".format(chat.title),<br/>reply_markup=InlineKeyboardMarkup(<br/>paginate_modules(<br/>curr_page - 1, CHAT_SETTINGS, "stngs", chat=chat_id<br/>)<br/>),<br/>)<div></div>elif next_match:<br/>chat_id = next_match.group(1)<br/>next_page = int(next_match.group(2))<br/>chat = bot.get_chat(chat_id)<br/>query.message.reply_text(<br/>"Hi there! There are quite a few settings for {} - go ahead and pick what "<br/>"you're interested in.".format(chat.title),<br/>reply_markup=InlineKeyboardMarkup(<br/>paginate_modules(<br/>next_page + 1, CHAT_SETTINGS, "stngs", chat=chat_id<br/>)<br/>),<br/>)<div></div>elif back_match:<br/>chat_id = back_match.group(1)<br/>chat = bot.get_chat(chat_id)<br/>query.message.reply_text(<br/>text="Hi there! There are quite a few settings for {} - go ahead and pick what "<br/>"you're interested in.".format(escape_markdown(chat.title)),<br/>parse_mode=ParseMode.MARKDOWN,<br/>reply_markup=InlineKeyboardMarkup(<br/>paginate_modules(0, CHAT_SETTINGS, "stngs", chat=chat_id)<br/>),<br/>)<div></div># ensure no spinny white circle<br/>bot.answer_callback_query(query.id)<br/>query.message.delete()<br/>except BadRequest as excp:<br/>if excp.message not in [<br/>"Message is not modified",<br/>"Query_id_invalid",<br/>"Message can't be deleted",<br/>]:<br/>LOGGER.exception("Exception in settings buttons. %s", str(query.data))<div></div><br/>@run_async<br/>def get_settings(update: Update, context: CallbackContext):<br/>chat = update.effective_chat # type: Optional[Chat]<br/>user = update.effective_user # type: Optional[User]<br/>msg = update.effective_message # type: Optional[Message]<div></div># ONLY send settings in PM<br/>if chat.type != chat.PRIVATE:<br/>if is_user_admin(chat, user.id):<br/>text = "Click here to get this chat's settings, as well as yours."<br/>msg.reply_text(<br/>text,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[<br/>InlineKeyboardButton(<br/>text="Settings",<br/>url="t.me/{}?start=stngs_{}".format(<br/>context.bot.username, chat.id<br/>),<br/>)<br/>]<br/>]<br/>),<br/>)<br/>else:<br/>text = "Click here to check your settings."<div></div>else:<br/>send_settings(chat.id, user.id, True)<div></div><br/>@run_async<br/>def donate(update: Update, context: CallbackContext):<br/>user = update.effective_message.from_user<br/>chat = update.effective_chat # type: Optional[Chat]<br/>bot = context.bot<br/>if chat.type == "private":<br/>update.effective_message.reply_text(<br/>text = "ʏᴏᴜ ᴄᴀɴ ᴅᴏɴᴀᴛᴇ ᴍᴇ ʜᴇʀᴇ", parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True, reply_markup=InlineKeyboardMarkup(<br/>[<br/>[ <br/>InlineKeyboardButton(text="Dᴏɴᴀᴛᴇ Mᴇ", url=f"{DONATION_LINK}"),<br/>]<br/>]<br/>)<br/>)<br/>else:<br/>try:<br/>bot.send_message(<br/>user.id,<br/>text = "ʏᴏᴜ ᴄᴀɴ ᴅᴏɴᴀᴛᴇ ᴍᴇ ʜᴇʀᴇ" ,<br/>parse_mode=ParseMode.MARKDOWN,<br/>disable_web_page_preview=True,<br/>reply_markup=InlineKeyboardMarkup(<br/>[<br/>[ <br/>InlineKeyboardButton(text="Dᴏɴᴀᴛᴇ Mᴇ", url=f"{DONATION_LINK}"),<br/>]<br/>]<br/>)<br/>)<div></div>update.effective_message.reply_text(<br/>"I've PM'ed you about donating to my creator!"<br/>)<br/>except Unauthorized:<br/>update.effective_message.reply_text(<br/>"Contact me in PM first to get donation information."<br/>)<div></div><br/>def migrate_chats(update: Update, context: CallbackContext):<br/>msg = update.effective_message # type: Optional[Message]<br/>if msg.migrate_to_chat_id:<br/>old_chat = update.effective_chat.id<br/>new_chat = msg.migrate_to_chat_id<br/>elif msg.migrate_from_chat_id:<br/>old_chat = msg.migrate_from_chat_id<br/>new_chat = update.effective_chat.id<br/>else:<br/>return<div></div>LOGGER.info("Migrating from %s, to %s", str(old_chat), str(new_chat))<br/>for mod in MIGRATEABLE:<br/>mod.__migrate__(old_chat, new_chat)<div></div>LOGGER.info("Successfully migrated!")<br/>raise DispatcherHandlerStop<div></div><br/>def main():<div></div>if SUPPORT_CHAT is not None and isinstance(SUPPORT_CHAT, str):<br/>try:<br/>dispatcher.bot.sendMessage(f"@{SUPPORT_CHAT}", "ᴛᴇᴄʜɴᴏ ʀᴏʙᴏᴛ ɪs ʀᴇsᴛᴀʀᴛᴇᴅ✅")<br/>except Unauthorized:<br/>LOGGER.warning(<br/>"Bot isnt able to send message to support_chat, go and check!"<br/>)<br/>except BadRequest as e:<br/>LOGGER.warning(e.message)<div></div>test_handler = CommandHandler("test", test)<br/>start_handler = CommandHandler("start", start)<div></div>help_handler = CommandHandler("help", get_help)<br/>help_callback_handler = CallbackQueryHandler(help_button, pattern=r"help_.*")<div></div>settings_handler = CommandHandler("settings", get_settings)<br/>settings_callback_handler = CallbackQueryHandler(settings_button, pattern=r"stngs_")<div></div>about_callback_handler = CallbackQueryHandler(tiana_callback_handler, pattern=r"tiana_")<br/>Tiana_callback_handler = CallbackQueryHandler(tiana_about_callback, pattern=r"about_")<div></div>donate_handler = CommandHandler("donate", donate)<br/>migrate_handler = MessageHandler(Filters.status_update.migrate, migrate_chats)<div></div># dispatcher.add_handler(test_handler)<br/>dispatcher.add_handler(start_handler)<br/>dispatcher.add_handler(help_handler)<br/>dispatcher.add_handler(about_callback_handler)<br/>dispatcher.add_handler(Tiana_callback_handler)<br/>dispatcher.add_handler(settings_handler)<br/>dispatcher.add_handler(help_callback_handler)<br/>dispatcher.add_handler(settings_callback_handler)<br/>dispatcher.add_handler(migrate_handler)<br/>dispatcher.add_handler(donate_handler)<div></div>dispatcher.add_error_handler(error_callback)<div></div>if WEBHOOK:<br/>LOGGER.info("Using webhooks.")<br/>updater.start_webhook(listen="0.0.0.0", port=PORT, url_path=TOKEN)<div></div>if CERT_PATH:<br/>updater.bot.set_webhook(url=URL + TOKEN, certificate=open(CERT_PATH, "rb"))<br/>else:<br/>updater.bot.set_webhook(url=URL + TOKEN)<div></div>else:<br/>LOGGER.info("Started Successfully")<br/>updater.start_polling(timeout=15, read_latency=4, clean=True)<div></div>if len(argv) not in (1, 3, 4):<br/>telethn.disconnect()<br/>else:<br/>telethn.run_until_disconnected()<div></div>updater.idle()<div></div><br/>if __name__ == "__main__":<br/>LOGGER.info("Successfully loaded modules: " + str(ALL_MODULES))<br/>telethn.start(bot_token=TOKEN)<br/>pbot.start()<br/>main()<div></div>